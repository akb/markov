// Generated by CoffeeScript 1.6.3
(function() {
  var IGNORED_ENTITIES, MarkovChain, RESET_ENTITIES, REWIND_ENTITIES, State, Transition,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  RESET_ENTITIES = [' ', "'", '.', '"', ',', '!', ':', ';', '?', '/'];

  IGNORED_ENTITIES = ['\n'];

  REWIND_ENTITIES = ['\b'];

  State = (function() {
    function State(options) {
      if (options == null) {
        options = {};
      }
      this.entity = options.entity || null;
      this.transitions = new Transition.Set(options.transitions);
      this.parent = options.parent;
    }

    State.prototype.process = function(entity) {
      var node, transition;
      if (!(transition = this.transitions.find(entity)[0])) {
        node = new State({
          entity: entity,
          parent: this
        });
        transition = new Transition({
          head: node,
          tail: this
        });
        this.transitions.append(transition);
      }
      transition.strength += 1;
      return transition.head;
    };

    State.prototype.nextStrongest = function() {
      var transitions;
      transitions = this.transitions.strongest();
      if (!transitions.length) {
        return;
      }
      if (transitions.length === 1) {
        return transitions[0].head;
      }
      return transitions[Math.floor(Math.random() * transitions.length)].head;
    };

    State.prototype.next = function() {
      var count, i, p, roll, _i, _len, _ref;
      roll = Math.random();
      count = 0.0;
      _ref = this.transitions.probabilities();
      for (p = _i = 0, _len = _ref.length; _i < _len; p = ++_i) {
        i = _ref[p];
        if ((count += p) >= roll) {
          return this.transitions.get(i).head;
        }
      }
    };

    State.prototype.previous = function() {
      var transition;
      transition = this.parent.transitions.find(function(t) {
        return t.head === this;
      });
      if ((transition.strength -= 1) < 1) {
        return this.parent.transitions.remove(transition);
      }
    };

    return State;

  })();

  Transition = (function() {
    function Transition(options) {
      if (options == null) {
        options = {};
      }
      this.tail = options.tail || null;
      this.head = options.head || null;
      this.strength = options.strength || 0;
    }

    return Transition;

  })();

  Transition.Set = (function() {
    function Set(transitions) {
      this.transitions = transitions || [];
    }

    Set.prototype.get = function(i) {
      return this.transitions[i];
    };

    Set.prototype.sum = function() {
      var sum, t, _i, _len, _ref;
      console.log(this.transitions);
      sum = 0;
      _ref = this.transitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        sum += t.strength;
      }
      return sum;
    };

    Set.prototype.probabilities = function() {
      var sum, t, _i, _len, _ref, _results;
      sum = this.sum();
      console.log(sum);
      _ref = this.transitions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(strength / sum);
      }
      return _results;
    };

    Set.prototype.find = function(entity) {
      var i, t, _ref, _results;
      _ref = this.transitions;
      _results = [];
      for (i in _ref) {
        t = _ref[i];
        if (t.head.entity === entity) {
          _results.push(t);
        }
      }
      return _results;
    };

    Set.prototype.append = function(transition) {
      return this.transitions.push(transition);
    };

    Set.prototype.maxStrength = function() {
      var max, t, _i, _len, _ref;
      max = 0;
      _ref = this.transitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.strength > max) {
          max = t.strength;
        }
      }
      return max;
    };

    Set.prototype.strongest = function() {
      var max, t, _i, _len, _ref, _results;
      max = this.maxStrength();
      _ref = this.transitions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.strength === max) {
          _results.push(t);
        }
      }
      return _results;
    };

    Set.prototype.remove = function(transition) {
      return delete this.transitions[this.transitions.indexOf(transition)];
    };

    return Set;

  })();

  MarkovChain = (function() {
    function MarkovChain(options) {
      if (options == null) {
        options = {};
      }
      this.nullstate = options.nullstate || new State;
      this.state = options.state || this.nullstate;
    }

    MarkovChain.prototype.reset = function() {
      return this.state = this.nullstate;
    };

    MarkovChain.prototype.rewind = function() {
      return this.state = this.state.back();
    };

    MarkovChain.prototype.process = function(entity) {
      if (__indexOf.call(IGNORED_ENTITIES, entity) >= 0) {
        return;
      }
      if (__indexOf.call(RESET_ENTITIES, entity) >= 0) {
        return this.reset();
      }
      if (__indexOf.call(REWIND_ENTITIES, entity) >= 0) {
        return this.rewind();
      }
      return this.state = this.state.process(entity);
    };

    MarkovChain.prototype.predict = function() {
      var prediction, state;
      prediction = [];
      state = this.state;
      if (!state.entity) {
        return;
      }
      while (state = state.next()) {
        prediction.push(state.entity);
      }
      return prediction;
    };

    return MarkovChain;

  })();

  window.State = State;

  window.Transition = Transition;

  window.MarkovChain = MarkovChain;

}).call(this);
