// Generated by CoffeeScript 1.6.3
(function() {
  var IGNORED_ENTITYS, MarkovChain, RESET_ENTITYS, State, Transition,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  RESET_ENTITYS = ['\n', ' ', "'", '.', '"', ',', '!', ':', ';', '?', '/'];

  IGNORED_ENTITYS = ['\n'];

  State = (function() {
    function State(options) {
      if (options == null) {
        options = {};
      }
      this.entity = options.entity || null;
      this.transitions = new Transition.Set(options.transitions);
    }

    State.prototype.process = function(entity) {
      var node, transition;
      if (!(transition = this.transitions.find(entity)[0])) {
        node = new State({
          entity: entity
        });
        transition = new Transition({
          head: node,
          tail: this
        });
        this.transitions.append(transition);
      }
      transition.strength += 1;
      return transition.head;
    };

    State.prototype.next = function() {
      var transitions;
      transitions = this.transitions.strongest();
      if (!transitions.length) {
        return;
      }
      if (transitions.length === 1) {
        return transitions[0].head;
      }
      return transitions[Math.floor(Math.random() * transitions.length)].head;
    };

    return State;

  })();

  Transition = (function() {
    function Transition(options) {
      if (options == null) {
        options = {};
      }
      this.tail = options.tail || null;
      this.head = options.head || null;
      this.strength = options.strength || 0;
    }

    return Transition;

  })();

  Transition.Set = (function() {
    function Set(transitions) {
      this.transitions = transitions || [];
    }

    Set.prototype.find = function(entity) {
      var i, t, _ref, _results;
      _ref = this.transitions;
      _results = [];
      for (i in _ref) {
        t = _ref[i];
        if (t.head.entity === entity) {
          _results.push(t);
        }
      }
      return _results;
    };

    Set.prototype.append = function(transition) {
      return this.transitions.push(transition);
    };

    Set.prototype.each = function(callback, context) {
      var t, _i, _len, _ref, _results;
      _ref = this.transitions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        _results.push(callback.call(context || this, t));
      }
      return _results;
    };

    Set.prototype.maxStrength = function() {
      var max, t, _i, _len, _ref;
      max = 0;
      _ref = this.transitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.strength > max) {
          max = t.strength;
        }
      }
      return max;
    };

    Set.prototype.strongest = function() {
      var max, t, _i, _len, _ref, _results;
      max = this.maxStrength();
      _ref = this.transitions;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.strength === max) {
          _results.push(t);
        }
      }
      return _results;
    };

    return Set;

  })();

  MarkovChain = (function() {
    function MarkovChain(options) {
      if (options == null) {
        options = {};
      }
      this.nullstate = options.nullstate || new State;
      this.state = options.state || this.nullstate;
    }

    MarkovChain.prototype.reset = function() {
      return this.state = this.nullstate;
    };

    MarkovChain.prototype.process = function(entity) {
      if (__indexOf.call(IGNORED_ENTITYS, entity) >= 0) {
        return;
      }
      if (__indexOf.call(RESET_ENTITYS, entity) >= 0) {
        return this.reset();
      }
      return this.state = this.state.process(entity);
    };

    MarkovChain.prototype.predict = function() {
      var prediction, state;
      prediction = [];
      state = this.state;
      if (!state.entity) {
        return;
      }
      while (state = state.next()) {
        prediction.push(state.entity);
      }
      return prediction;
    };

    return MarkovChain;

  })();

  window.State = State;

  window.Transition = Transition;

  window.MarkovChain = MarkovChain;

}).call(this);
