// Generated by CoffeeScript 1.6.3
(function() {
  var Markov, argv, commands, fs, _ref;

  if (process.argv == null) {
    return;
  }

  fs = require('fs');

  Markov = require('./markov').Markov;

  commands = {};

  commands.create = function(inputfile) {
    var markov;
    try {
      fs.statSync(inputfile);
      markov = new Markov(JSON.parse(fs.readFileSync(inputfile).toString()));
      process.stdout.write(markov.generate() + '\n');
      return process.exit(0);
    } catch (_error) {
      process.stderr.write("" + inputfile + " does not exist\n");
      return process.exit(1);
    }
  };

  commands.learn = function() {
    var buffer, inputComplete, markov, timer;
    buffer = '';
    inputComplete = false;
    markov = new Markov;
    process.stdin.setEncoding('utf8');
    process.stdin.on('readable', function() {
      var chunk;
      chunk = process.stdin.read();
      if (chunk == null) {
        return;
      }
      return buffer += chunk;
    });
    process.stdin.on('end', function() {
      var i, _i, _ref;
      buffer = buffer.split(/\b/);
      for (i = _i = 0, _ref = buffer.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (buffer[i] === "'") {
          buffer[i - 1] = buffer[i - 1] + buffer[i] + buffer[i + 1];
          buffer.splice(i, 2);
        }
      }
      return inputComplete = true;
    });
    return timer = setInterval(function() {
      var char;
      if (inputComplete && !buffer.length) {
        clearInterval(timer);
        process.stdout.write(JSON.stringify(markov));
      }
      if (!buffer.length) {
        return;
      }
      char = buffer[0];
      buffer = buffer.slice(1);
      char = char.replace(/"/g, '');
      char = char.replace(/\s+/g, ' ');
      if (char === ' ') {
        return;
      }
      return markov.transition(char);
    }, 0);
  };

  argv = require('minimist')(process.argv.slice(2));

  if ((_ref = commands[argv._[0]]) != null) {
    _ref.apply(this, argv._.slice(1));
  }

}).call(this);
