// Generated by CoffeeScript 1.6.3
(function() {
  var Markov, fs, markov, seed;

  fs = require('fs');

  Markov = (function() {
    function Markov(options) {
      var t, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      this.state = options.state || ' ';
      this.transitions = [];
      if (options.transitions != null) {
        _ref = options.transitions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          this.transitions.push(new Markov.Transition(t));
        }
      }
    }

    Markov.prototype.transition = function(state) {
      var t, transition, _i, _len, _ref;
      if (!state.match(/[a-z' ]+/i)) {
        return;
      }
      _ref = this.transitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.tailMatches(state) && t.headMatches(this.state)) {
          transition = t;
        }
      }
      if (transition == null) {
        transition = new Markov.Transition(this.state, state);
        this.transitions.push(transition);
      }
      return this.state = transition.execute();
    };

    Markov.prototype.reset = function() {
      return this.state = ' ';
    };

    Markov.prototype.random = function() {
      return this.state = this.transitions[Math.floor(Math.random() * this.transitions.length)].tail;
    };

    Markov.prototype.predict = function() {
      var choices, random, sum, t, _i, _j, _len, _len1;
      choices = (function() {
        var _i, _len, _ref, _results;
        _ref = this.transitions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.head === this.state) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      if (!choices.length) {
        return;
      }
      sum = 0;
      for (_i = 0, _len = choices.length; _i < _len; _i++) {
        t = choices[_i];
        sum += t.count;
      }
      random = Math.floor(Math.random() * sum);
      for (_j = 0, _len1 = choices.length; _j < _len1; _j++) {
        t = choices[_j];
        random -= t.count;
        if (random <= 0) {
          return this.state = t.tail;
        }
      }
    };

    Markov.prototype.generate = function() {
      var buffer, last, next;
      buffer = '';
      this.random();
      next = '';
      while (!next.match(/\w+/)) {
        next = this.predict();
      }
      buffer += next[0].toUpperCase() + next.slice(1);
      while (next) {
        last = next;
        next = this.predict();
        if (!(next.match(/[',:;.!?\s]/) || last.match(/\s/))) {
          buffer += ' ';
        }
        if (next) {
          buffer += next;
        }
        if (next.match(/[.!?]/)) {
          break;
        }
      }
      return buffer;
    };

    return Markov;

  })();

  Markov.Transition = (function() {
    function Transition(head, tail) {
      if (arguments.length === 1) {
        this.tail = head.tail;
        this.count = head.count;
        this.head = head.head;
      } else {
        this.head = head;
        this.tail = tail;
        this.count = 0;
      }
    }

    Transition.prototype.headMatches = function(state) {
      return state.toLowerCase() === this.head.toLowerCase();
    };

    Transition.prototype.tailMatches = function(state) {
      return state.toLowerCase() === this.tail.toLowerCase();
    };

    Transition.prototype.execute = function() {
      this.count++;
      return this.tail;
    };

    return Transition;

  })();

  if (!process.argv) {
    return;
  }

  markov = null;

  seed = function() {
    var buffer, done, timer;
    try {
      fs.statSync('markov.json');
      markov = new Markov(JSON.parse(fs.readFileSync('markov.json').toString()));
      return console.log(markov.generate());
    } catch (_error) {
      markov = new Markov;
    }
    buffer = '';
    done = false;
    process.stdin.setEncoding('utf8');
    process.stdin.on('readable', function() {
      var chunk;
      chunk = process.stdin.read();
      if (chunk == null) {
        return;
      }
      return buffer += chunk;
    });
    process.stdin.on('end', function() {
      var i, _i, _ref;
      buffer = buffer.split(/\b/);
      for (i = _i = 0, _ref = buffer.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (buffer[i] === "'") {
          buffer[i - 1] = buffer[i - 1] + buffer[i] + buffer[i + 1];
          buffer.splice(i, 2);
        }
      }
      return done = true;
    });
    return timer = setInterval(function() {
      var char;
      if (done && !buffer.length) {
        clearInterval(timer);
        fs.writeFileSync('markov.json', JSON.stringify(markov));
        console.log(markov.generate());
      }
      if (!buffer.length) {
        return;
      }
      char = buffer[0];
      buffer = buffer.slice(1);
      char = char.replace(/"/g, '');
      char = char.replace(/\s+/g, ' ');
      if (char === ' ') {
        return;
      }
      return markov.transition(char);
    }, 0);
  };

  seed();

}).call(this);
