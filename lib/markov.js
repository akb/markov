// Generated by CoffeeScript 1.6.3
(function() {
  var Transition;

  Transition = require('./transition').Transition;

  module.exports.Markov = (function() {
    function Markov(options) {
      var t, _i, _len, _ref;
      if (options == null) {
        options = {};
      }
      this.state = options.state || ' ';
      this.transitions = [];
      if (options.transitions != null) {
        _ref = options.transitions;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          this.transitions.push(new Transition(t));
        }
      }
    }

    Markov.prototype.transition = function(state) {
      var t, transition, _i, _len, _ref;
      if (!state.match(/[a-z' ]+/i)) {
        return;
      }
      _ref = this.transitions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (t.tailMatches(state) && t.headMatches(this.state)) {
          transition = t;
        }
      }
      if (transition == null) {
        transition = new Transition(this.state, state);
        this.transitions.push(transition);
      }
      return this.state = transition.execute();
    };

    Markov.prototype.reset = function() {
      return this.state = ' ';
    };

    Markov.prototype.random = function() {
      return this.state = this.transitions[Math.floor(Math.random() * this.transitions.length)].tail;
    };

    Markov.prototype.predict = function() {
      var choices, random, sum, t, _i, _j, _len, _len1;
      choices = (function() {
        var _i, _len, _ref, _results;
        _ref = this.transitions;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          if (t.head === this.state) {
            _results.push(t);
          }
        }
        return _results;
      }).call(this);
      if (!choices.length) {
        return;
      }
      sum = 0;
      for (_i = 0, _len = choices.length; _i < _len; _i++) {
        t = choices[_i];
        sum += t.count;
      }
      random = Math.floor(Math.random() * sum);
      for (_j = 0, _len1 = choices.length; _j < _len1; _j++) {
        t = choices[_j];
        random -= t.count;
        if (random <= 0) {
          return this.state = t.tail;
        }
      }
    };

    Markov.prototype.generate = function() {
      var buffer, last, next;
      buffer = '';
      this.random();
      next = '';
      while (!next.match(/\w+/)) {
        next = this.predict();
      }
      buffer += next[0].toUpperCase() + next.slice(1);
      while (next) {
        last = next;
        next = this.predict();
        if (!(next.match(/[',:;.!?\s]/) || last.match(/\s/))) {
          buffer += ' ';
        }
        if (next) {
          buffer += next;
        }
        if (next.match(/[.!?]/)) {
          break;
        }
      }
      return buffer;
    };

    return Markov;

  })();

}).call(this);
